"""
Vulnerability Scanner
Comprehensive security testing and vulnerability detection system
"""

import re
import json
import asyncio
import aiohttp
import hashlib
import subprocess
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, asdict
from enum import Enum
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class VulnerabilityType(Enum):
    XSS = "cross_site_scripting"
    SQL_INJECTION = "sql_injection"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    CSRF = "cross_site_request_forgery"
    AUTHENTICATION = "authentication_bypass"
    AUTHORIZATION = "authorization_bypass"
    INFORMATION_DISCLOSURE = "information_disclosure"
    INSECURE_HEADERS = "insecure_headers"
    WEAK_CRYPTO = "weak_cryptography"
    DEPENDENCY = "vulnerable_dependency"
    CONFIGURATION = "security_misconfiguration"

class Severity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

@dataclass
class Vulnerability:
    id: str
    type: VulnerabilityType
    severity: Severity
    title: str
    description: str
    location: str
    evidence: str
    recommendation: str
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None
    references: List[str] = None
    timestamp: datetime = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()
        if self.references is None:
            self.references = []

@dataclass
class ScanResult:
    scan_id: str
    target: str
    start_time: datetime
    end_time: Optional[datetime]
    vulnerabilities: List[Vulnerability]
    scan_type: str
    status: str
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}

class VulnerabilityScanner:
    def __init__(self):
        self.payloads = self._load_payloads()
        self.scan_results: Dict[str, ScanResult] = {}
        
    def _load_payloads(self) -> Dict[str, List[str]]:
        """Load attack payloads for different vulnerability types"""
        return {
            "xss": [
                "<script>alert('XSS')</script>",
                "javascript:alert('XSS')",
                "<img src=x onerror=alert('XSS')>",
                "';alert('XSS');//",
                "<svg onload=alert('XSS')>",
                "{{7*7}}",  # Template injection
                "${7*7}",   # Expression language injection
            ],
            "sql_injection": [
                "' OR '1'='1",
                "' UNION SELECT NULL--",
                "'; DROP TABLE users--",
                "1' AND 1=1--",
                "1' AND 1=2--",
                "admin'--",
                "' OR 1=1#",
                "1; SELECT * FROM users",
            ],
            "command_injection": [
                "; ls -la",
                "| whoami",
                "&& cat /etc/passwd",
                "`id`",
                "$(whoami)",
                "; ping -c 1 127.0.0.1",
                "| dir",
                "&& type C:\\Windows\\System32\\drivers\\etc\\hosts",
            ],
            "path_traversal": [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "....//....//....//etc/passwd",
                "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
                "..%252f..%252f..%252fetc%252fpasswd",
                "....\\\\....\\\\....\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts",
            ],
            "ldap_injection": [
                "*)(uid=*",
                "*)(|(uid=*))",
                "admin)(&(password=*))",
                "*))%00",
            ]
        }
    
    async def scan_web_application(self, base_url: str, endpoints: List[str]) -> ScanResult:
        """Comprehensive web application security scan"""
        scan_id = self._generate_scan_id()
        scan_result = ScanResult(
            scan_id=scan_id,
            target=base_url,
            start_time=datetime.now(),
            end_time=None,
            vulnerabilities=[],
            scan_type="web_application",
            status="running"
        )
        
        self.scan_results[scan_id] = scan_result
        
        try:
            # Test for various vulnerabilities
            await self._test_xss_vulnerabilities(base_url, endpoints, scan_result)
            await self._test_sql_injection(base_url, endpoints, scan_result)
            await self._test_command_injection(base_url, endpoints, scan_result)
            await self._test_path_traversal(base_url, endpoints, scan_result)
            await self._test_authentication_bypass(base_url, endpoints, scan_result)
            await self._test_security_headers(base_url, scan_result)
            await self._test_csrf_protection(base_url, endpoints, scan_result)
            
            scan_result.status = "completed"
            
        except Exception as e:
            logger.error(f"Scan failed: {e}")
            scan_result.status = "failed"
            scan_result.metadata["error"] = str(e)
        
        finally:
            scan_result.end_time = datetime.now()
        
        return scan_result
    
    async def _test_xss_vulnerabilities(self, base_url: str, endpoints: List[str], scan_result: ScanResult):
        """Test for Cross-Site Scripting vulnerabilities"""
        async with aiohttp.ClientSession() as session:
            for endpoint in endpoints:
                for payload in self.payloads["xss"]:
                    try:
                        # Test GET parameters
                        url = f"{base_url}{endpoint}?test={payload}"
                        async with session.get(url) as response:
                            content = await response.text()
                            
                            if payload in content and "text/html" in response.headers.get("content-type", ""):
                                vulnerability = Vulnerability(
                                    id=self._generate_vuln_id(),
                                    type=VulnerabilityType.XSS,
                                    severity=Severity.HIGH,
                                    title="Reflected Cross-Site Scripting (XSS)",
                                    description=f"The application reflects user input without proper sanitization",
                                    location=f"GET {endpoint}",
                                    evidence=f"Payload: {payload}",
                                    recommendation="Implement proper input validation and output encoding",
                                    cwe_id="CWE-79"
                                )
                                scan_result.vulnerabilities.append(vulnerability)
                        
                        # Test POST parameters
                        data = {"test": payload}
                        async with session.post(f"{base_url}{endpoint}", data=data) as response:
                            content = await response.text()
                            
                            if payload in content and "text/html" in response.headers.get("content-type", ""):
                                vulnerability = Vulnerability(
                                    id=self._generate_vuln_id(),
                                    type=VulnerabilityType.XSS,
                                    severity=Severity.HIGH,
                                    title="Stored Cross-Site Scripting (XSS)",
                                    description=f"The application stores and displays user input without proper sanitization",
                                    location=f"POST {endpoint}",
                                    evidence=f"Payload: {payload}",
                                    recommendation="Implement proper input validation and output encoding",
                                    cwe_id="CWE-79"
                                )
                                scan_result.vulnerabilities.append(vulnerability)
                    
                    except Exception as e:
                        logger.debug(f"XSS test failed for {endpoint}: {e}")
    
    async def _test_sql_injection(self, base_url: str, endpoints: List[str], scan_result: ScanResult):
        """Test for SQL Injection vulnerabilities"""
        async with aiohttp.ClientSession() as session:
            for endpoint in endpoints:
                for payload in self.payloads["sql_injection"]:
                    try:
                        # Test GET parameters
                        url = f"{base_url}{endpoint}?id={payload}"
                        async with session.get(url) as response:
                            content = await response.text()
                            
                            # Look for SQL error messages
                            sql_errors = [
                                "sql syntax", "mysql_fetch", "ora-", "postgresql",
                                "sqlite_", "sqlstate", "syntax error", "database error"
                            ]
                            
                            if any(error in content.lower() for error in sql_errors):
                                vulnerability = Vulnerability(
                                    id=self._generate_vuln_id(),
                                    type=VulnerabilityType.SQL_INJECTION,
                                    severity=Severity.CRITICAL,
                                    title="SQL Injection",
                                    description="The application is vulnerable to SQL injection attacks",
                                    location=f"GET {endpoint}",
                                    evidence=f"Payload: {payload}",
                                    recommendation="Use parameterized queries and input validation",
                                    cwe_id="CWE-89"
                                )
                                scan_result.vulnerabilities.append(vulnerability)
                    
                    except Exception as e:
                        logger.debug(f"SQL injection test failed for {endpoint}: {e}")
    
    async def _test_command_injection(self, base_url: str, endpoints: List[str], scan_result: ScanResult):
        """Test for Command Injection vulnerabilities"""
        async with aiohttp.ClientSession() as session:
            for endpoint in endpoints:
                for payload in self.payloads["command_injection"]:
                    try:
                        url = f"{base_url}{endpoint}?cmd={payload}"
                        async with session.get(url) as response:
                            content = await response.text()
                            
                            # Look for command execution indicators
                            command_indicators = [
                                "uid=", "gid=", "root:", "administrator", "system32",
                                "etc/passwd", "windows\\system32"
                            ]
                            
                            if any(indicator in content.lower() for indicator in command_indicators):
                                vulnerability = Vulnerability(
                                    id=self._generate_vuln_id(),
                                    type=VulnerabilityType.COMMAND_INJECTION,
                                    severity=Severity.CRITICAL,
                                    title="Command Injection",
                                    description="The application executes user input as system commands",
                                    location=f"GET {endpoint}",
                                    evidence=f"Payload: {payload}",
                                    recommendation="Avoid executing user input as commands, use safe APIs",
                                    cwe_id="CWE-78"
                                )
                                scan_result.vulnerabilities.append(vulnerability)
                    
                    except Exception as e:
                        logger.debug(f"Command injection test failed for {endpoint}: {e}")
    
    async def _test_path_traversal(self, base_url: str, endpoints: List[str], scan_result: ScanResult):
        """Test for Path Traversal vulnerabilities"""
        async with aiohttp.ClientSession() as session:
            for endpoint in endpoints:
                for payload in self.payloads["path_traversal"]:
                    try:
                        url = f"{base_url}{endpoint}?file={payload}"
                        async with session.get(url) as response:
                            content = await response.text()
                            
                            # Look for file content indicators
                            file_indicators = [
                                "root:x:", "daemon:", "bin:", "sys:", "[boot loader]",
                                "# hosts file", "localhost"
                            ]
                            
                            if any(indicator in content.lower() for indicator in file_indicators):
                                vulnerability = Vulnerability(
                                    id=self._generate_vuln_id(),
                                    type=VulnerabilityType.PATH_TRAVERSAL,
                                    severity=Severity.HIGH,
                                    title="Path Traversal",
                                    description="The application allows access to files outside the intended directory",
                                    location=f"GET {endpoint}",
                                    evidence=f"Payload: {payload}",
                                    recommendation="Validate and sanitize file paths, use whitelisting",
                                    cwe_id="CWE-22"
                                )
                                scan_result.vulnerabilities.append(vulnerability)
                    
                    except Exception as e:
                        logger.debug(f"Path traversal test failed for {endpoint}: {e}")
    
    async def _test_authentication_bypass(self, base_url: str, endpoints: List[str], scan_result: ScanResult):
        """Test for Authentication Bypass vulnerabilities"""
        async with aiohttp.ClientSession() as session:
            auth_endpoints = [ep for ep in endpoints if any(auth in ep.lower() for auth in ["login", "auth", "admin"])]
            
            for endpoint in auth_endpoints:
                try:
                    # Test without credentials
                    async with session.get(f"{base_url}{endpoint}") as response:
                        if response.status == 200:
                            content = await response.text()
                            
                            # Look for admin/protected content
                            if any(indicator in content.lower() for indicator in ["admin", "dashboard", "control panel"]):
                                vulnerability = Vulnerability(
                                    id=self._generate_vuln_id(),
                                    type=VulnerabilityType.AUTHENTICATION,
                                    severity=Severity.HIGH,
                                    title="Authentication Bypass",
                                    description="Protected resources are accessible without authentication",
                                    location=f"GET {endpoint}",
                                    evidence=f"Status: {response.status}",
                                    recommendation="Implement proper authentication checks",
                                    cwe_id="CWE-287"
                                )
                                scan_result.vulnerabilities.append(vulnerability)
                
                except Exception as e:
                    logger.debug(f"Auth bypass test failed for {endpoint}: {e}")
    
    async def _test_security_headers(self, base_url: str, scan_result: ScanResult):
        """Test for missing security headers"""
        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(base_url) as response:
                    headers = response.headers
                    
                    # Check for missing security headers
                    security_headers = {
                        "X-Content-Type-Options": "nosniff",
                        "X-Frame-Options": ["DENY", "SAMEORIGIN"],
                        "X-XSS-Protection": "1; mode=block",
                        "Strict-Transport-Security": None,
                        "Content-Security-Policy": None,
                        "Referrer-Policy": None
                    }
                    
                    for header, expected in security_headers.items():
                        if header not in headers:
                            vulnerability = Vulnerability(
                                id=self._generate_vuln_id(),
                                type=VulnerabilityType.INSECURE_HEADERS,
                                severity=Severity.MEDIUM,
                                title=f"Missing Security Header: {header}",
                                description=f"The {header} security header is not set",
                                location=base_url,
                                evidence=f"Header '{header}' not found in response",
                                recommendation=f"Add the {header} header to all responses",
                                cwe_id="CWE-693"
                            )
                            scan_result.vulnerabilities.append(vulnerability)
                        elif expected and isinstance(expected, list):
                            if headers[header] not in expected:
                                vulnerability = Vulnerability(
                                    id=self._generate_vuln_id(),
                                    type=VulnerabilityType.INSECURE_HEADERS,
                                    severity=Severity.LOW,
                                    title=f"Weak Security Header: {header}",
                                    description=f"The {header} header has a weak value",
                                    location=base_url,
                                    evidence=f"Header '{header}': {headers[header]}",
                                    recommendation=f"Set {header} to one of: {', '.join(expected)}",
                                    cwe_id="CWE-693"
                                )
                                scan_result.vulnerabilities.append(vulnerability)
            
            except Exception as e:
                logger.debug(f"Security headers test failed: {e}")
    
    async def _test_csrf_protection(self, base_url: str, endpoints: List[str], scan_result: ScanResult):
        """Test for CSRF protection"""
        async with aiohttp.ClientSession() as session:
            for endpoint in endpoints:
                try:
                    # Test POST without CSRF token
                    data = {"test": "value"}
                    async with session.post(f"{base_url}{endpoint}", data=data) as response:
                        if response.status == 200:
                            vulnerability = Vulnerability(
                                id=self._generate_vuln_id(),
                                type=VulnerabilityType.CSRF,
                                severity=Severity.MEDIUM,
                                title="Missing CSRF Protection",
                                description="The application accepts POST requests without CSRF tokens",
                                location=f"POST {endpoint}",
                                evidence=f"Status: {response.status}",
                                recommendation="Implement CSRF token validation for state-changing operations",
                                cwe_id="CWE-352"
                            )
                            scan_result.vulnerabilities.append(vulnerability)
                
                except Exception as e:
                    logger.debug(f"CSRF test failed for {endpoint}: {e}")
    
    async def scan_dependencies(self, requirements_file: str) -> ScanResult:
        """Scan dependencies for known vulnerabilities"""
        scan_id = self._generate_scan_id()
        scan_result = ScanResult(
            scan_id=scan_id,
            target=requirements_file,
            start_time=datetime.now(),
            end_time=None,
            vulnerabilities=[],
            scan_type="dependency",
            status="running"
        )
        
        try:
            # Use safety to check for known vulnerabilities
            result = subprocess.run(
                ["safety", "check", "-r", requirements_file, "--json"],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                # Parse safety output
                try:
                    safety_data = json.loads(result.stdout)
                    for vuln in safety_data:
                        vulnerability = Vulnerability(
                            id=self._generate_vuln_id(),
                            type=VulnerabilityType.DEPENDENCY,
                            severity=self._map_safety_severity(vuln.get("severity", "medium")),
                            title=f"Vulnerable Dependency: {vuln['package_name']}",
                            description=vuln["advisory"],
                            location=f"{vuln['package_name']} {vuln['installed_version']}",
                            evidence=f"CVE: {vuln.get('cve', 'N/A')}",
                            recommendation=f"Update to version {vuln.get('safe_version', 'latest')}",
                            cve_id=vuln.get("cve")
                        )
                        scan_result.vulnerabilities.append(vulnerability)
                except json.JSONDecodeError:
                    pass
            
            scan_result.status = "completed"
            
        except Exception as e:
            logger.error(f"Dependency scan failed: {e}")
            scan_result.status = "failed"
            scan_result.metadata["error"] = str(e)
        
        finally:
            scan_result.end_time = datetime.now()
        
        return scan_result
    
    def _map_safety_severity(self, safety_severity: str) -> Severity:
        """Map safety severity to our severity enum"""
        mapping = {
            "critical": Severity.CRITICAL,
            "high": Severity.HIGH,
            "medium": Severity.MEDIUM,
            "low": Severity.LOW
        }
        return mapping.get(safety_severity.lower(), Severity.MEDIUM)
    
    def _generate_scan_id(self) -> str:
        """Generate unique scan ID"""
        return f"scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{hashlib.md5(str(datetime.now()).encode()).hexdigest()[:8]}"
    
    def _generate_vuln_id(self) -> str:
        """Generate unique vulnerability ID"""
        return f"vuln_{hashlib.md5(str(datetime.now()).encode()).hexdigest()[:12]}"
    
    def get_scan_result(self, scan_id: str) -> Optional[ScanResult]:
        """Get scan result by ID"""
        return self.scan_results.get(scan_id)
    
    def get_all_scans(self) -> List[ScanResult]:
        """Get all scan results"""
        return list(self.scan_results.values())
    
    def export_results(self, scan_id: str, format: str = "json") -> str:
        """Export scan results in specified format"""
        scan_result = self.get_scan_result(scan_id)
        if not scan_result:
            raise ValueError(f"Scan {scan_id} not found")
        
        if format == "json":
            return json.dumps(asdict(scan_result), default=str, indent=2)
        elif format == "csv":
            import csv
            import io
            
            output = io.StringIO()
            writer = csv.writer(output)
            
            # Header
            writer.writerow([
                "ID", "Type", "Severity", "Title", "Location", 
                "Description", "Recommendation", "CWE", "Timestamp"
            ])
            
            # Vulnerabilities
            for vuln in scan_result.vulnerabilities:
                writer.writerow([
                    vuln.id, vuln.type.value, vuln.severity.value,
                    vuln.title, vuln.location, vuln.description,
                    vuln.recommendation, vuln.cwe_id, vuln.timestamp
                ])
            
            return output.getvalue()
        else:
            raise ValueError(f"Unsupported format: {format}")

# Security test runner
class SecurityTestRunner:
    def __init__(self):
        self.scanner = VulnerabilityScanner()
    
    async def run_comprehensive_scan(self, config: Dict[str, Any]) -> Dict[str, ScanResult]:
        """Run comprehensive security scan"""
        results = {}
        
        # Web application scan
        if "web_app" in config:
            web_config = config["web_app"]
            result = await self.scanner.scan_web_application(
                web_config["base_url"],
                web_config["endpoints"]
            )
            results["web_app"] = result
        
        # Dependency scan
        if "dependencies" in config:
            dep_config = config["dependencies"]
            result = await self.scanner.scan_dependencies(dep_config["requirements_file"])
            results["dependencies"] = result
        
        return results
    
    def generate_security_report(self, results: Dict[str, ScanResult]) -> Dict[str, Any]:
        """Generate comprehensive security report"""
        total_vulns = sum(len(result.vulnerabilities) for result in results.values())
        
        severity_counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0
        }
        
        for result in results.values():
            for vuln in result.vulnerabilities:
                severity_counts[vuln.severity.value] += 1
        
        # Calculate risk score (0-100)
        risk_score = min(100, (
            severity_counts["critical"] * 10 +
            severity_counts["high"] * 5 +
            severity_counts["medium"] * 2 +
            severity_counts["low"] * 1
        ))
        
        return {
            "summary": {
                "total_vulnerabilities": total_vulns,
                "severity_breakdown": severity_counts,
                "risk_score": risk_score,
                "scan_date": datetime.now().isoformat()
            },
            "scans": {scan_type: asdict(result) for scan_type, result in results.items()},
            "recommendations": self._generate_recommendations(results)
        }
    
    def _generate_recommendations(self, results: Dict[str, ScanResult]) -> List[str]:
        """Generate security recommendations based on findings"""
        recommendations = []
        
        # Analyze vulnerabilities and generate recommendations
        all_vulns = []
        for result in results.values():
            all_vulns.extend(result.vulnerabilities)
        
        vuln_types = set(vuln.type for vuln in all_vulns)
        
        if VulnerabilityType.XSS in vuln_types:
            recommendations.append("Implement comprehensive input validation and output encoding")
        
        if VulnerabilityType.SQL_INJECTION in vuln_types:
            recommendations.append("Use parameterized queries and ORM frameworks")
        
        if VulnerabilityType.INSECURE_HEADERS in vuln_types:
            recommendations.append("Configure security headers (CSP, HSTS, X-Frame-Options)")
        
        if VulnerabilityType.DEPENDENCY in vuln_types:
            recommendations.append("Regularly update dependencies and monitor for vulnerabilities")
        
        return recommendations

# Export main components
__all__ = [
    'VulnerabilityScanner',
    'SecurityTestRunner', 
    'Vulnerability',
    'ScanResult',
    'VulnerabilityType',
    'Severity'
]